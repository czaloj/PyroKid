package pyrokid {
	import flash.display.DisplayObject;
	import flash.display.MovieClip;
	import flash.display.Sprite;
    import flash.utils.Dictionary;
    import physics.*;
    import pyrokid.entities.*;
    import pyrokid.tools.*;
    
    public class Level extends Sprite {
        
        /* Information from level recipe. Doesn't change while playing game. */
        public var walls:Array;
		public var recipe:Object;
        
        /* Physics information. Generated by physics engine. */
		public var islands:Array;
		public var columns:Array;

        /* Items that don't have a physics representation. */
        public var fireballs:RingBuffer;
        public var briefClips:RingBuffer;
		public var background:CaveBackground;
        
        /* View objects that translate information between entities and physics objects. */
		public var islandViews:Array;
		public var rectViews:Array;
        
        /* FreeEntities (not bound to tiles). */
        public var player:Player;
        public var enemies:Array;
		
		/* TileEntities (bound to tiles except when falling). */
		public var tileEntityGrid:Array; // 2D grid, indexed by [y][x]
		public var movingTiles:Array; // invariant: movingTiles and tileEntityGrid are mutually exclusive sets
		public var onFire:Array;
		
        /* Variables for use throughout the playing of a level. */
		public var frameCount:int = 0;
        public var dirty:Boolean = false; // whether dead items need to be cleared this frame
        
        public function Level(recipe:Object):void {
			reset(recipe);
        }
		
		public function numCellsWide():int {
			return walls[0].length;
		}
		
		public function numCellsTall():int {
			return walls.length;
		}

        public function reset(recipe:Object):void {
            LevelRecipe.complete(recipe);
            Key.reset();
            frameCount = 0;
            Utils.removeAllChildren(this);
            
			this.recipe = recipe;
            walls = recipe.walls;
			onFire = [];
			islandViews = [];
			rectViews = [];
			movingTiles = [];
            enemies = [];
            tileEntityGrid = Utils.newArrayOfSize(walls);
            
            background = new CaveBackground(Utils.getW(walls), Utils.getH(walls));
            this.addChild(background);
			
            setupTiles();
            setupFreeEntities();
            setupMiscellaneous();
        }
        
        private function setupTiles():void {
            //islands = IslandSimulator.ConstructIslandsFromIds(recipe.islands, walls);
            
            var islandCellMap:Dictionary = Utils.getCellMap(recipe.islands);
            var entityCellMap:Dictionary = Utils.getCellMap(recipe.tileEntities);
            
            // Create physics islands and game islands
            islands = [];
            var gameIslands:Dictionary = new Dictionary();
            for (var strId:String in islandCellMap) {
                var id:int = int(strId);
                var physIsland:PhysIsland = IslandSimulator.ConstructIsland(islandCellMap[id], walls);
                islands.push(physIsland);
                
                var gameIsland:Island = new Island();
                gameIsland.entityList = [];
                gameIsland.tileEntityGrid = Utils.newArrayOfSize(physIsland.tileGrid);
                gameIsland.globalAnchor = physIsland.globalAnchor.copy();
                gameIslands[id] = gameIsland;
                
				islandViews.push(new ViewPIsland(gameIsland, physIsland));
            }
            columns = IslandSimulator.ConstructCollisionColumns(islands);
            
            // Create tile entities and populate entity grids
            for (var strId:String in entityCellMap) {
                var id:int = int(strId);
                var coors:Array = entityCellMap[id];
                
                // all ids should be the same, so just use the first
                var tileCode:int = walls[coors[0].y][coors[0].x];
                var islandId:int = recipe.islands[coors[0].y][coors[0].x];
                
                var parentIsland:Island = gameIslands[islandId];
                var entity:TileEntity = getEntityFromTileCode(tileCode);
                addChild(entity);
                
                var globalAnchor:Vector2 = Utils.getAnchor(coors);
                entity.islandAnchor = globalAnchor.copy().SubV(parentIsland.globalAnchor);
                
                entity.parentIsland = parentIsland;
                entity.cells = coors.map(function(coor) {
                    return coor.copy().SubV(globalAnchor.copyAsVec2i());
                });
                entity.x = globalAnchor.x * Constants.CELL;
                entity.y = globalAnchor.y * Constants.CELL;
                
                for each (var coor:Vector2i in coors) { // relative to global space
                    tileEntityGrid[coor.y][coor.x] = entity;
                }
                for each (var cell:Vector2i in entity.cells) { // relative to entity's anchor
                    parentIsland.tileEntityGrid[cell.y + entity.islandAnchor.y][cell.x + entity.islandAnchor.x] = entity;
                }
                
                parentIsland.entityList.push(entity);
                
                entity.finalizeCells();
            }
        }
        
        private function getEntityFromTileCode(tileCode:int):TileEntity {
            var tileEntity:TileEntity;
            var realObjCode:int = Math.abs(tileCode); // TODO get rid of -- Aaron
            if (realObjCode == Constants.OIL_TILE_CODE) {
                return new BurnForever(0, 0, realObjCode);
            }
            if (realObjCode == Constants.WOOD_TILE_CODE) {
                return new BurnQuickly(0, 0, realObjCode);
            }
            return new NonFlammableTile(0, 0, realObjCode);
        }
        
        private function setupFreeEntities():void {
			player = new Player(this);
			initializeFreeEntity(player, recipe.playerStart[0], recipe.playerStart[1]);
            
            for (var i:int = 0; i < recipe.freeEntities.length; i++) {
                var enemy:BackAndForthEnemy;
                if (recipe.freeEntities[i][2] == Constants.SPIDER_CODE) {
                    enemy = new Spider(this);
                } else {
                    enemy = new BurnForeverEnemy(this);
                }
                initializeFreeEntity(enemy, recipe.freeEntities[i][0], recipe.freeEntities[i][1]);
                enemies.push(enemy);
			}
        }
        
        private function initializeFreeEntity(freeEntity:FreeEntity, startCellX:int, startCellY:int):void {
            freeEntity.x = startCellX * Constants.CELL;
            freeEntity.y = startCellY * Constants.CELL;
            addChild(freeEntity);
            rectViews.push(new ViewPRect(freeEntity, freeEntity.genPhysRect()));
        }
        
        private function setupMiscellaneous():void {
            var self:Level = this;
            fireballs = new RingBuffer(5, function(o:Object) {
                var dispObj:Fireball = o as Fireball;
                
                if (dispObj.fizzOut) {
                    var fizz:MovieClip = new Embedded.FireballFizzSWF() as MovieClip;
                    fizz.x = dispObj.x;
                    fizz.y = dispObj.y;
                    fizz.rotation = dispObj.rotation;
                    self.addChild(fizz);
                    self.briefClips.push(fizz);
                } else {
                    var sploosh:MovieClip = new Embedded.FiresplooshSWF() as MovieClip;
                    sploosh.x = dispObj.x;
                    sploosh.y = dispObj.y;
                    self.addChild(sploosh);
                    self.briefClips.push(sploosh);
                }
                
                self.removeChild(dispObj);
            });
            
            briefClips = new RingBuffer(50, function(o:Object) {
                if (o is DisplayObject) {
                    var dispObj = o as DisplayObject;
                    self.removeChild(dispObj);
                }
            });
        }
		
        
        //////////////////////////////////
        //////////////////////////////////
        //////////////////////////////////
        //////////////////////////////////
        
        public function fireballUpdate():void {
				
            
            for (var i:int = 0; i < fireballs.size(); i++) {
                var fireball:Fireball = fireballs.get(i) as Fireball;
				fireball.x += fireball.speedX;
                fireball.y += fireball.speedY;
                
                // ignite TileEntities
				var cellX = Utils.realToCell(fireball.x);
				var cellY = Utils.realToCell(fireball.y);
				var entity:TileEntity = Utils.index(tileEntityGrid, cellX, cellY);
				if (entity != null) {
					// remove fireball from list, also delete from stage
					fireballs.markForDeletion(fireball);
				    entity.ignite(this, frameCount);
				}
                
                // ignite FreeEntities
                for (var j:int = 0; j < enemies.length; j++) {
                    var spider:BackAndForthEnemy = enemies[j] as BackAndForthEnemy;
                    if(spider != null) {
                        if (fireball.hitTestObject(spider)) {
                            fireballs.markForDeletion(fireball);
                            spider.ignite(this, frameCount);
                            
                            //XXX
                            //level.harmfulObjects.splice(level.harmfulObjects.indexOf(spider),1);
                            break;
                        }
                    }
                }
                
                // fireball expiration
                if (fireball.isDead()) {
                    fireball.fizzOut = true;
                    fireballs.markForDeletion(fireball);
                }
            }
            
			fireballs.deleteAllMarked();			
		}
        
        public function launchFireball(range:Number, direction:int):void {
            var fball:Fireball = new Fireball();
            fball.setRange(range);
            fball.x = player.getCenter().x;
            fball.y = player.getCenter().y;
            fball.setDirection(direction);
            fireballs.push(fball);
            addChild(fball);
			Embedded.fireballSound.play();
        }
        
        public function removeDead():void {
            if (!dirty) {
                return;
            }
            
            rectViews = rectViews.filter(function(view) {
                return !view.sprite.isDead;
            });
            enemies = enemies.filter(function(enemy) {
                if (enemy.isDead) {
                    removeChild(enemy);
                }
                return !enemy.isDead;
            });
            
            islands = [];
            var islandRemoved:Boolean = false;
            islandViews = islandViews.filter(function(view) {
                var alive:Boolean = !view.sprite.isDead;
                if (alive) {
                    islands.push(view.phys);
                } else {
                    removeChild(view.sprite);
                    islandRemoved = true;
                }
                return alive;
            });
            if (islandRemoved) {
                columns = IslandSimulator.ConstructCollisionColumns(islands);
            }
            
            for (var y:int = 0; y < tileEntityGrid.length; y++) {
                for (var x:int = 0; x < tileEntityGrid[0].length; x++) {
                    var entity:TileEntity = tileEntityGrid[y][x];
                    if (entity != null && entity.isDead) {
                        tileEntityGrid[y][x] = null;
                    }
                }
            }
            movingTiles = movingTiles.filter(function(tile) {
                return !tile.sprite.isDead;
            });
            onFire = onFire.filter(function(tile) {
                return !tile.isDead;
            });
        }
    }

}