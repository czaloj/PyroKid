package pyrokid {
	import flash.display.DisplayObject;
	import flash.display.MovieClip;
	import flash.display.Sprite;
    import flash.utils.Dictionary;
    import physics.*;
    import pyrokid.entities.*;
    import pyrokid.tools.*;
    
    public class Level extends Sprite {
        
        /* Information from level recipe. Doesn't change while playing game. */
        public var walls:Array;
		public var recipe:Object;
        
        /* Physics information. Generated by physics engine. */
		public var islands:Array;
		public var columns:Array;

        /* Items that don't have a physics representation. */
        public var projectiles:RingBuffer;
        public var briefClips:RingBuffer;
        public var delayedFunctions:Dictionary;
		public var background:CaveBackground;
        
        /* View objects that translate information between entities and physics objects. */
		public var islandViews:Array;
		public var rectViews:Array;
        
        /* FreeEntities (not bound to tiles). */
        public var player:Player;
        public var enemies:Array;
		
		/* TileEntities (bound to tiles except when falling). */
		public var tileEntityGrid:Array; // 2D grid, indexed by [y][x]
		public var movingTiles:Array; // invariant: movingTiles and tileEntityGrid are mutually exclusive sets
		public var onFire:Array;
		
        /* Variables for use throughout the playing of a level. */
		public var frameCount:int;
        public var dirty:Boolean; // whether dead items need to be cleared this frame
        public var gameOverState:int;
        
        public function Level(recipe:Object):void {
			reset(recipe);
        }
		
		public function get cellWidth():int {
			return walls[0].length;
		}
		public function get cellHeight():int {
			return walls.length;
		}

        public function get worldWidth():int {
            return cellWidth * Constants.CELL;
        }
        public function get worldHeight():int {
            return cellHeight * Constants.CELL;
        }
        
        public function reset(recipe:Object):void {
            LevelRecipe.complete(recipe);
            Key.reset();
            frameCount = 0;
            Utils.removeAllChildren(this);
            
			this.recipe = recipe;
            walls = recipe.walls;
			onFire = [];
			rectViews = [];
			movingTiles = [];
            enemies = [];
            islands = [];
			islandViews = [];
            tileEntityGrid = Utils.newArrayOfSize(walls);
            
		    frameCount = 0;
            dirty = false;
            gameOverState = Constants.GAME_NOT_OVER;
            
            background = new CaveBackground(Utils.getW(walls), Utils.getH(walls));
            this.addChild(background);
			
            setupTiles();
            setupFreeEntities();
            for each (var enemy:FreeEntity in enemies) {
                if (enemy is Exit) {
                    setChildIndex(enemy, 0); // move exits behind all characters
                }
            }
            setChildIndex(background, 0);
            setupMiscellaneous();
        }
        
        private function setupTiles():void {
            var entityCellMap:Dictionary = Utils.getCellMap(recipe.tileEntities);
            
            // build physTiles grid
            var physTiles:Array = Utils.newArrayOfSize(recipe.walls);
            Utils.foreach(physTiles, function(x:int, y:int, element:TileEntity):void {
                if (recipe.walls[y][x] != Constants.EMPTY_TILE_CODE) {
                    var connectorBools:Array = Utils.getBooleansFromInt(recipe.islands[y][x]);
                    var isFalling:Boolean = Constants.GROUNDED_TYPES.indexOf(recipe.walls[y][x]) == -1;
                    physTiles[y][x] = new PhysBox(connectorBools, isFalling);
                }
            });
            
            // Create physics islands and game islands
            islands = IslandSimulator.ConstructIslands(physTiles);
            columns = IslandSimulator.ConstructCollisionColumns(islands);
            for each (var physIsland:PhysIsland in islands) {
                var gameIsland:Island = new Island(physIsland);
                islandViews.push(new ViewPIsland(gameIsland, physIsland));
            }
            
            // Create tile entities and populate entity grids
            for (var strId:String in entityCellMap) {
                var id:int = int(strId);
                var coors:Array = entityCellMap[id];
                
                // all ids should be the same, so just use the first
                var tileCode:int = recipe.walls[coors[0].y][coors[0].x];
                
                var parentIsland:Island = findParentIsland(coors, islandViews);
                var entity:TileEntity = getEntityFromTileCode(tileCode);
                addChild(entity);
                
                // construct entity and setup sprite
                var globalAnchor:Vector2 = Utils.getAnchor(coors);
                entity.cells = coors.map(function(coor) {
                    return coor.copy().SubV(globalAnchor.copyAsVec2i());
                });
                entity.x = globalAnchor.x * Constants.CELL;
                entity.y = globalAnchor.y * Constants.CELL;
                entity.finalizeCells();
                
                parentIsland.addEntity(entity, globalAnchor);
                entity.addEdges(recipe.edges);
                
                for each (var coor:Vector2i in coors) { // relative to global space
                    tileEntityGrid[coor.y][coor.x] = entity;
                }
            }
            
            for each (var islandView:ViewPIsland in islandViews) {
                islandView.sprite.connectors = Connector.getConnectorSprites(recipe.islands, islandView.sprite);
                for each (var sprite:Connector in islandView.sprite.connectors) {
                    addChild(sprite);
                }
                islandView.sprite.setConnectorPositions();
            }
        }
        
        private static function findParentIsland(coors:Array, islandViews:Array):Island {
            return islandViews.filter(function(element) {
                var physIsland:PhysIsland = element.phys;
                var coor:Vector2i = coors[0].copy().SubV(physIsland.globalAnchor.copyAsVec2i());
                return Utils.index(physIsland.tileGrid, coor.x, coor.y) != null;
            })[0].sprite;
        }
        
        private function getEntityFromTileCode(tileCode:int):TileEntity {
            var tileEntity:TileEntity;
            var realObjCode:int = Math.abs(tileCode); // TODO get rid of -- Aaron
            if (realObjCode == Constants.OIL_TILE_CODE) {
                return new BurnForever(0, 0, realObjCode);
            }
            if (realObjCode == Constants.WOOD_TILE_CODE) {
                return new BurnQuickly(0, 0, realObjCode);
            }
            return new NonFlammableTile(0, 0, realObjCode);
        }
        
        private function setupFreeEntities():void {
			player = new Player(this);
			initializeFreeEntity(player, recipe.playerStart[0], recipe.playerStart[1]);
            
            for (var i:int = 0; i < recipe.freeEntities.length; i++) {
                var enemy:FreeEntity;
                if (recipe.freeEntities[i][2] == Constants.SPIDER_CODE) {
                    enemy = new Spider(this);
                } else if (recipe.freeEntities[i][2] == Constants.BAT_CODE) {
                    enemy = new WaterBat(this);
                } else if (recipe.freeEntities[i][2] == Constants.BOMB_EXIT_CODE) {
                    enemy = new Exit(this);
                } else if (recipe.freeEntities[i][2] == Constants.HOLE_EXIT_CODE) {
                    enemy = new Exit(this, true);
                } else {
                    enemy = new BurnForeverEnemy(this);
                }
                initializeFreeEntity(enemy, recipe.freeEntities[i][0], recipe.freeEntities[i][1]);
                enemies.push(enemy);
			}
        }
        
        private function initializeFreeEntity(freeEntity:FreeEntity, startCellX:int, startCellY:int):void {
            freeEntity.x = startCellX * Constants.CELL;
            freeEntity.y = startCellY * Constants.CELL;
            addChild(freeEntity);
            rectViews.push(new ViewPRect(freeEntity, freeEntity.genPhysRect()));
        }
        
        private function setupMiscellaneous():void {
            var self:Level = this;
            projectiles = new RingBuffer(50, function(o:Object) {
                var dispObj:ProjectileBall = o as ProjectileBall;
                
                var position:Vector2 = new Vector2(dispObj.x, dispObj.y);
                var briefClip:BriefClip;
                var clip:MovieClip;
                var velocity:Vector2 = new Vector2();
                if (dispObj is Fireball) {
                    if (dispObj.fizzOut) {
                        clip = new Embedded.FireballFizzSWF() as MovieClip;
                    } else {
                        clip = new Embedded.FiresplooshSWF() as MovieClip;
                    }
                    briefClip = new BriefClip(position, clip, velocity);
                    briefClip.rotation = dispObj.rotation;
                    self.addChild(briefClip);
                    self.briefClips.push(briefClip);
                }
                
                
                self.removeChild(dispObj);
            });
            
            briefClips = new RingBuffer(50, function(o:Object) {
                if (o is DisplayObject) {
                    var dispObj = o as DisplayObject;
                    self.removeChild(dispObj);
                    
                    if (o.clip is Player) {
                        gameOverState = Constants.GAME_OVER_COMPLETE;
                    }
                }
            });
            
            delayedFunctions = new Dictionary();
        }
		
        
        //////////////////////////////////
        //////////////////////////////////
        //////////////////////////////////
        //////////////////////////////////
        
        public function projectileUpdate():void {
				
            
            for (var i:int = 0; i < projectiles.size(); i++) {
                var projectile:ProjectileBall = projectiles.get(i) as ProjectileBall;
				projectile.x += projectile.speedX;
                projectile.y += projectile.speedY;
                
                // ignite TileEntities
                // TODO hit falling objects with fireball -- Aaron
                
                var cellX:int = Utils.realToCell(projectile.x);
                var cellY:int = Utils.realToCell(projectile.y);
                var entity:TileEntity = Utils.index(tileEntityGrid, cellX, cellY);
                if (entity != null) {
                    // remove fireball from list, also delete from stage
                    projectiles.markForDeletion(projectile);
                    var dir:int;
                    if (projectile.speedY > 0) {
                        dir = Cardinal.PY;
                    } else if (projectile.speedY < 0) {
                        dir = Cardinal.NY;
                    } else if (projectile.speedX > 0) {
                        dir = Cardinal.PX;
                    } else if (projectile.speedX < 0) {
                        dir = Cardinal.NX;
                    }
                    var coor:Vector2i = new Vector2i(cellX, cellY).SubV(entity.getGlobalAnchorAsVec2i());
                    if (projectile is Fireball) {
                        entity.ignite(this, coor, dir);
                    } else if (projectile is Waterball) {
                        // TODO extinguish fire -- Aaron
                        trace("sploosh!");
                    }
                }
                
                // ignite FreeEntities
                if (projectile is Fireball) {
                    for each (var freeEntity:FreeEntity in enemies) {
                        if (freeEntity.isTouching(projectile)) {
                            projectiles.markForDeletion(projectile);
                            freeEntity.ignite(this);
                            break;
                        }
                    }
                }
                
                
                if (projectile is Waterball) {
                    if (player.isTouching(projectile)) {
                        projectiles.markForDeletion(projectile);
                        player.velocity.AddV(new Vector2(projectile.speedX, projectile.speedY));
                    }
                }
                
                // If waterball and fireball collide, remove both
                for (var j:int = 0; j < projectiles.size(); j++) {
                    var otherProj:ProjectileBall = projectiles.get(j) as ProjectileBall;
                    if (projectile is Fireball && otherProj is Waterball) {
                        if (Utils.distance(projectile, otherProj) < 20) {
                            projectiles.markForDeletion(projectile);
                            projectiles.markForDeletion(otherProj);
                        }
                    }
                }
                
                // projectile expiration
                if (projectile.isDead()) {
                    if(projectile is Fireball) {
                        Fireball(projectile).fizzOut = true;
                    }
                    projectiles.markForDeletion(projectile);
                }
            }
            
			projectiles.deleteAllMarked();			
		}
        
        public function launchFireball(range:Number, direction:int):void {
            var fball:Fireball = new Fireball();
            fball.setRange(range);
            fball.x = player.getCenter().x;
            fball.y = player.getCenter().y;
            fball.setDirection(direction);
            projectiles.push(fball);
            addChild(fball);
			Embedded.fireballSound.play();
        }
        
        public function launchWaterball(x:int, y:int, range:Number, direction:int):void {
            var wball:Waterball = new Waterball();
            wball.x = x;
            wball.y = y;
            wball.setDirection(direction);
            projectiles.push(wball);
            addChild(wball);
        }
        
        /* Removes dead items in the level and returns true iff the player died. */
        public function removeDead():void {
            if (!dirty) {
                return;
            }
            var self:Level = this;
            
            rectViews = rectViews.filter(function(view) {
                return !view.sprite.isDead;
            });
            enemies = enemies.filter(function(enemy) {
                if (enemy.isDead) {
                    removeChild(enemy);
                }
                return !enemy.isDead;
            });
            
            var brokenIslandViews:Array = [];
            var oldIslandViews = islandViews;
            islandViews = [];
            islands = [];
            for each (var islandView:ViewPIsland in oldIslandViews) {
                var gameIsland:Island = islandView.sprite;
                var physIsland:PhysIsland = islandView.phys;
                
                var entityRemoved:Boolean = false;
                gameIsland.entityList = gameIsland.entityList.filter(function(entity) {
                    if (entity.isDead) {
                        removeChild(entity);
                        for each (var coor:Vector2i in entity.coorsInIsland()) {
                            gameIsland.tileEntityGrid[coor.y][coor.x] = null;
                            physIsland.tileGrid[coor.y][coor.x] = null;
                        }
                        entityRemoved = true;
                    }
                    return !entity.isDead;
                });
                
                if (entityRemoved) {
                    brokenIslandViews.push(islandView);
                } else {
                    islands.push(physIsland);
                    islandViews.push(islandView);
                }
            }
            
            for each (var brokenIslandView:ViewPIsland in brokenIslandViews) {
                if (brokenIslandView.sprite.entityList.length == 0) {
                    continue;
                }
                
                var brokenPhysIsland:PhysIsland = brokenIslandView.phys;
                var entities:Array = brokenIslandView.sprite.entityList;
                    
                var newIslandViews:Array = [];
                var newIslands:Array = IslandSimulator.ConstructIslands(brokenPhysIsland.tileGrid);
                for each (var newPhysIsland:PhysIsland in newIslands) {
                    newPhysIsland.velocity = brokenPhysIsland.velocity.copy();
                    var newGameIsland:Island = new Island(newPhysIsland);
                    islands.push(newPhysIsland);
                    var newIslandView:ViewPIsland = new ViewPIsland(newGameIsland, newPhysIsland);
                    newIslandViews.push(newIslandView);
                    islandViews.push(newIslandView);
                }
                for each (var entity:TileEntity in entities) {
                    var gameIsland:Island = findParentIsland(entity.coorsInIsland(), newIslandViews);
                    gameIsland.addEntity(entity, entity.islandAnchor.copyAsVec2());
                }
                for each (var newPhysIsland:PhysIsland in newIslands) {
                    newPhysIsland.globalAnchor.AddV(brokenPhysIsland.globalAnchor);
                }
                for each (var sprite:Connector in brokenIslandView.sprite.connectors) {
                    var coor1:Vector2i = sprite.coorInIsland;
                    var coor2:Vector2i = Cardinal.getVector2i(sprite.direction).AddV(sprite.coorInIsland);
                    var islandFound:Boolean = false;
                    for each (var islandView:ViewPIsland in newIslandViews) {
                        if (Utils.index(islandView.sprite.tileEntityGrid, coor1.x, coor1.y)
                                && Utils.index(islandView.sprite.tileEntityGrid, coor2.x, coor2.y)) {
                            islandView.sprite.connectors[Connector.getDictKey(coor1, sprite.direction)] = sprite;
                            sprite.setSpriteLocationFromIslandAnchor(islandView.sprite.globalAnchor);
                            islandFound = true;
                            break;
                        }
                    }
                    if (!islandFound) {
                        removeChild(sprite);
                    }
                }
            }
            
            movingTiles = [];
            for each (var islandView:ViewPIsland in islandViews) {
                if (islandView.sprite.isMoving()) {
                    movingTiles.push(islandView);
                }
            }
            
            if (brokenIslandViews.length > 0) {
                columns = IslandSimulator.ConstructCollisionColumns(islands);
            }
            
            for (var y:int = 0; y < tileEntityGrid.length; y++) {
                for (var x:int = 0; x < tileEntityGrid[0].length; x++) {
                    var entity:TileEntity = tileEntityGrid[y][x];
                    if (entity != null && entity.isDead) {
                        tileEntityGrid[y][x] = null;
                    }
                }
            }
            onFire = onFire.filter(function(tile) {
                return !tile.isDead;
            });
            
            if (gameOverState == Constants.GAME_OVER_FADING) {
                if (player.parent == this) {
                    removeChild(player);
                }
            }
        }
    }

}