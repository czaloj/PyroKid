package pyrokid {
	import flash.display.DisplayObject;
	import flash.display.MovieClip;
	import flash.display.Sprite;
    import flash.utils.Dictionary;
    import physics.*;
    import pyrokid.entities.*;
    import pyrokid.tools.*;
    
    public class Level extends Sprite {
        
        /* Information from level recipe. Doesn't change while playing game. */
        public var walls:Array;
		public var recipe:Object;
        
        /* Physics information. Generated by physics engine. */
		public var islands:Array;
		public var columns:Array;

        /* Items that don't have a physics representation. */
        public var fireballs:RingBuffer;
        public var briefClips:RingBuffer;
		public var background:CaveBackground;
        
        /* View objects that translate information between entities and physics objects. */
		public var islandViews:Array;
		public var rectViews:Array;
        
        /* FreeEntities (not bound to tiles). */
        public var player:Player;
        public var enemies:Array;
		
		/* TileEntities (bound to tiles except when falling). */
		public var tileEntityGrid:Array; // 2D grid, indexed by [y][x]
		public var movingTiles:Array; // invariant: movingTiles and tileEntityGrid are mutually exclusive sets
		public var onFire:Array;
		
        /* Variables for use throughout the playing of a level. */
		public var frameCount:int = 0;
        public var dirty:Boolean = false; // whether dead items need to be cleared this frame
        
        public function Level(recipe:Object):void {
			reset(recipe);
        }
		
		public function numCellsWide():int {
			return walls[0].length;
		}
		
		public function numCellsTall():int {
			return walls.length;
		}

        public function reset(recipe:Object):void {
            LevelRecipe.complete(recipe);
            Key.reset();
            frameCount = 0;
            Utils.removeAllChildren(this);
            
			this.recipe = recipe;
            walls = recipe.walls;
			onFire = [];
			rectViews = [];
			movingTiles = [];
            enemies = [];
            
            background = new CaveBackground(Utils.getW(walls), Utils.getH(walls));
            this.addChild(background);
			
            islands = [];
			islandViews = [];
            tileEntityGrid = Utils.newArrayOfSize(walls);
            setupTiles(islands, islandViews, tileEntityGrid, walls);
            setupFreeEntities();
            setupMiscellaneous();
        }
        
        private function setupTiles(islands:Array, islandViews:Array, tileEntityGrid:Array, tileIdGrid:Array):void {
            //islands = IslandSimulator.ConstructIslandsFromIds(recipe.islands, walls);
            var islandCellMap:Dictionary = Utils.getCellMap(recipe.islands);
            var entityCellMap:Dictionary = Utils.getCellMap(recipe.tileEntities);
            
            // Create physics islands and game islands
            var gameIslands:Dictionary = new Dictionary();
            for (var strId:String in islandCellMap) {
                var id:int = int(strId);
                var physIsland:PhysIsland = IslandSimulator.ConstructIsland(islandCellMap[id], tileIdGrid);
                islands.push(physIsland);
                
                var gameIsland:Island = new Island(physIsland);
                gameIslands[id] = gameIsland;
                
				islandViews.push(new ViewPIsland(gameIsland, physIsland));
            }
            columns = IslandSimulator.ConstructCollisionColumns(islands);
            
            // Create tile entities and populate entity grids
            for (var strId:String in entityCellMap) {
                var id:int = int(strId);
                var coors:Array = entityCellMap[id];
                
                // all ids should be the same, so just use the first
                var tileCode:int = tileIdGrid[coors[0].y][coors[0].x];
                var islandId:int = recipe.islands[coors[0].y][coors[0].x];
                
                var parentIsland:Island = gameIslands[islandId];
                var entity:TileEntity = getEntityFromTileCode(tileCode);
                addChild(entity);
                
                // construct entity and setup sprite
                var globalAnchor:Vector2 = Utils.getAnchor(coors);
                entity.cells = coors.map(function(coor) {
                    return coor.copy().SubV(globalAnchor.copyAsVec2i());
                });
                entity.x = globalAnchor.x * Constants.CELL;
                entity.y = globalAnchor.y * Constants.CELL;
                entity.finalizeCells();
                
                parentIsland.addEntity(entity, globalAnchor);
                
                for each (var coor:Vector2i in coors) { // relative to global space
                    tileEntityGrid[coor.y][coor.x] = entity;
                }
            }
        }
        
        private function getEntityFromTileCode(tileCode:int):TileEntity {
            var tileEntity:TileEntity;
            var realObjCode:int = Math.abs(tileCode); // TODO get rid of -- Aaron
            if (realObjCode == Constants.OIL_TILE_CODE) {
                return new BurnForever(0, 0, realObjCode);
            }
            if (realObjCode == Constants.WOOD_TILE_CODE) {
                return new BurnQuickly(0, 0, realObjCode);
            }
            return new NonFlammableTile(0, 0, realObjCode);
        }
        
        private function setupFreeEntities():void {
			player = new Player(this);
			initializeFreeEntity(player, recipe.playerStart[0], recipe.playerStart[1]);
            
            for (var i:int = 0; i < recipe.freeEntities.length; i++) {
                var enemy:BackAndForthEnemy;
                if (recipe.freeEntities[i][2] == Constants.SPIDER_CODE) {
                    enemy = new Spider(this);
                } else {
                    enemy = new BurnForeverEnemy(this);
                }
                initializeFreeEntity(enemy, recipe.freeEntities[i][0], recipe.freeEntities[i][1]);
                enemies.push(enemy);
			}
        }
        
        private function initializeFreeEntity(freeEntity:FreeEntity, startCellX:int, startCellY:int):void {
            freeEntity.x = startCellX * Constants.CELL;
            freeEntity.y = startCellY * Constants.CELL;
            addChild(freeEntity);
            rectViews.push(new ViewPRect(freeEntity, freeEntity.genPhysRect()));
        }
        
        private function setupMiscellaneous():void {
            var self:Level = this;
            fireballs = new RingBuffer(5, function(o:Object) {
                var dispObj:Fireball = o as Fireball;
                
                if (dispObj.fizzOut) {
                    var fizz:MovieClip = new Embedded.FireballFizzSWF() as MovieClip;
                    fizz.x = dispObj.x;
                    fizz.y = dispObj.y;
                    fizz.rotation = dispObj.rotation;
                    self.addChild(fizz);
                    self.briefClips.push(fizz);
                } else {
                    var sploosh:MovieClip = new Embedded.FiresplooshSWF() as MovieClip;
                    sploosh.x = dispObj.x;
                    sploosh.y = dispObj.y;
                    self.addChild(sploosh);
                    self.briefClips.push(sploosh);
                }
                
                self.removeChild(dispObj);
            });
            
            briefClips = new RingBuffer(50, function(o:Object) {
                if (o is DisplayObject) {
                    var dispObj = o as DisplayObject;
                    self.removeChild(dispObj);
                }
            });
        }
		
        
        //////////////////////////////////
        //////////////////////////////////
        //////////////////////////////////
        //////////////////////////////////
        
        public function fireballUpdate():void {
				
            
            for (var i:int = 0; i < fireballs.size(); i++) {
                var fireball:Fireball = fireballs.get(i) as Fireball;
				fireball.x += fireball.speedX;
                fireball.y += fireball.speedY;
                
                // ignite TileEntities
                // TODO hit falling objects with fireball -- Aaron
				var cellX = Utils.realToCell(fireball.x);
				var cellY = Utils.realToCell(fireball.y);
				var entity:TileEntity = Utils.index(tileEntityGrid, cellX, cellY);
				if (entity != null) {
					// remove fireball from list, also delete from stage
					fireballs.markForDeletion(fireball);
				    entity.ignite(this, frameCount);
				}
                
                // ignite FreeEntities
                for (var j:int = 0; j < enemies.length; j++) {
                    var spider:BackAndForthEnemy = enemies[j] as BackAndForthEnemy;
                    if (spider != null) {
                        // TODO use hitTestObject on spider's hitbox
                        if (fireball.hitTestObject(spider)) {
                            fireballs.markForDeletion(fireball);
                            spider.ignite(this, frameCount);
                            
                            //XXX
                            //level.harmfulObjects.splice(level.harmfulObjects.indexOf(spider),1);
                            break;
                        }
                    }
                }
                
                // fireball expiration
                if (fireball.isDead()) {
                    fireball.fizzOut = true;
                    fireballs.markForDeletion(fireball);
                }
            }
            
			fireballs.deleteAllMarked();			
		}
        
        public function launchFireball(range:Number, direction:int):void {
            var fball:Fireball = new Fireball();
            fball.setRange(range);
            fball.x = player.getCenter().x;
            fball.y = player.getCenter().y;
            fball.setDirection(direction);
            fireballs.push(fball);
            addChild(fball);
			Embedded.fireballSound.play();
        }
        
        public function removeDead():void {
            if (!dirty) {
                return;
            }
            
            rectViews = rectViews.filter(function(view) {
                return !view.sprite.isDead;
            });
            enemies = enemies.filter(function(enemy) {
                if (enemy.isDead) {
                    removeChild(enemy);
                }
                return !enemy.isDead;
            });
            
            var brokenIslandViews:Array = [];
            var oldIslandViews = islandViews;
            islandViews = [];
            islands = [];
            for each (var islandView:ViewPIsland in oldIslandViews) {
                var gameIsland:Island = islandView.sprite;
                var physIsland:PhysIsland = islandView.phys;
                
                var entityRemoved:Boolean = false;
                gameIsland.entityList = gameIsland.entityList.filter(function(entity) {
                    if (entity.isDead) {
                        removeChild(entity);
                        for each (var coor:Vector2i in entity.coorsInIsland()) {
                            gameIsland.tileEntityGrid[coor.y][coor.x] = null;
                        }
                        entityRemoved = true;
                    }
                    return !entity.isDead;
                });
                
                if (entityRemoved) {
                    brokenIslandViews.push(islandView);
                } else {
                    islands.push(physIsland);
                    islandViews.push(islandView);
                }
            }
            
            for each (var brokenIslandView:ViewPIsland in brokenIslandViews) {
                if (brokenIslandView.sprite.entityList.length == 0) {
                    continue;
                }
                
                var brokenPhysIsland:PhysIsland = brokenIslandView.phys;
                var grid:Array = brokenIslandView.sprite.tileEntityGrid;
                var physBoxGrid:Array = brokenPhysIsland.tileGrid;
                
                var visitedCoors:HashSet = new HashSet();
                Utils.foreach(grid, function(x:int, y:int, tileEntity:TileEntity):void {
                    var coor:Vector2i = new Vector2i(x, y);
                    if (tileEntity == null || visitedCoors.contains(coor)) {
                        return;
                    }
                    
                    // Construct island by doing BFS on this coordinate.
                    var entities:HashSet = new HashSet(true);
                    var coorsInNewIsland:Array = [];
                    var isNeighbor:Function = function(coor:Vector2i):Boolean {
                        return grid[coor.y][coor.x] != null;
                    };
                    var processNode:Function = function(coor:Vector2i):Boolean {
                        entities.add(grid[coor.y][coor.x]);
                        coorsInNewIsland.push(coor);
                        visitedCoors.add(coor);
                        return false;
                    };
                    Utils.BFS(Utils.getW(grid), Utils.getH(grid), coor, isNeighbor, processNode);
                    
                    var physIsland:PhysIsland = IslandSimulator.ConstructIsland(coorsInNewIsland, physBoxGrid);
                    physIsland.globalAnchor.AddV(brokenPhysIsland.globalAnchor);
                    physIsland.velocity = brokenPhysIsland.velocity.copy();
                    var gameIsland:Island = new Island(physIsland);
                    for each (var entity:TileEntity in entities) {
                        gameIsland.addEntity(entity, entity.getGlobalAnchor());
                    }
                    islands.push(physIsland);
                    islandViews.push(new ViewPIsland(gameIsland, physIsland));
                });
            }
            
            movingTiles = [];
            for each (var islandView:ViewPIsland in islandViews) {
                if (islandView.sprite.isMoving()) {
                    movingTiles.push(islandView);
                }
            }
            
            if (brokenIslandViews.length > 0) {
                columns = IslandSimulator.ConstructCollisionColumns(islands);
            }
            
            for (var y:int = 0; y < tileEntityGrid.length; y++) {
                for (var x:int = 0; x < tileEntityGrid[0].length; x++) {
                    var entity:TileEntity = tileEntityGrid[y][x];
                    if (entity != null && entity.isDead) {
                        tileEntityGrid[y][x] = null;
                    }
                }
            }
            onFire = onFire.filter(function(tile) {
                return !tile.isDead;
            });
        }
    }

}