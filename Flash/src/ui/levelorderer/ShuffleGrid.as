package ui.levelorderer{	import ui.levelorderer.gs.TweenLite;	import ui.levelorderer.gs.easing.Expo;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.utils.Dictionary;		/**	 * @author justinwindle	 */	public class ShuffleGrid extends Sprite 	{		public var tweenTime : Number = 0.2;		public var itemAlphaOff : Number = 0.8;		public function get numCells() : int		{			return _rows * _cols;		}		public function get rows() : int		{			return _rows;		}		public function get cols() : int		{			return _cols;		}		private var _rows : int;		private var _cols : int;		private var _padd : int;		private var _rowSize : int;		private var _colSize : int;		private var _index : Array;		private var _items : Array;		private var _numItems : int;		private var _dictionary : Dictionary;		private var _currentItem : ShuffleGridItem;						public var onScreenXOffset:int = 0;		public var onScreenYOffset:int = 0;		public function ShuffleGrid(rows : int, cols : int, rowSize : int, colSize : int, padding : Number = 0)		{			_rows = rows;			_cols = cols;			_padd = padding;			_rowSize = rowSize;			_colSize = colSize;			_numItems = 0;						initIndex();		}		public function addItem(item : ShuffleGridItem) : ShuffleGridItem		{			var col : int = _numItems % _cols;			var row : int = Math.floor(_numItems / _cols);			var itemVO : ShuffleGridItemVO = new ShuffleGridItemVO();			var position : Point = getPosition(row, col);						itemVO.row = row;			itemVO.col = col;			itemVO.item = item;						item.x = position.x;			item.y = position.y;						item.mouseEnabled = true;			item.buttonMode = true;						item.addEventListener(MouseEvent.MOUSE_DOWN, onItemPress);			item.addEventListener(MouseEvent.MOUSE_UP, onItemRelease);						addChild(item);						_items.push(item);			_index[row][col] = itemVO;			_dictionary[item] = itemVO;			_numItems++;						return item;		}		public function getItemAt(index : int) : ShuffleGridItem		{			return _items[index];		}		public function getItemAtPosition(row : int, col : int) : ShuffleGridItem		{			var gridItem:ShuffleGridItemVO = _index[row][col];			return gridItem.item;		}		private function initIndex() : void		{			_dictionary = new Dictionary();			_index = new Array(_rows);			_items = [];						for (var i : int = 0;i < _rows; i++)			{				_index[i] = new Array(_cols);			}		}		private function shuffleItems() : void		{			var itemVO : ShuffleGridItemVO = _dictionary[_currentItem];			var cell : Point = getCell(_currentItem.x, _currentItem.y);						var col : int = cell.x;			var row : int = cell.y;						if(col == itemVO.col && row == itemVO.row)			{				return;			}						var hMove : int = col - itemVO.col;			var vMove : int = row - itemVO.row;						var i : int;			var item : ShuffleGridItemVO;			var move : Array = [];			if(hMove < 0)			{				for (i = itemVO.col - 1;i >= itemVO.col + hMove; i--)				{					if(_index[itemVO.row][i])					{						item = _index[itemVO.row][i];						item.col++;												_index[item.row][item.col] = item;						move.push(item);					}				}			}			else			{				for (i = itemVO.col + 1;i <= itemVO.col + hMove; i++)				{					if(_index[itemVO.row][i])					{						item = _index[itemVO.row][i];						item.col--;												_index[item.row][item.col] = item;						move.push(item);					}				}			}			if(vMove < 0)			{				for (i = itemVO.row - 1;i >= itemVO.row + vMove; i--)				{					if(_index[i][itemVO.col + hMove])					{						item = _index[i][itemVO.col + hMove];						item.row++;												_index[item.row][item.col] = item;						move.push(item);					}				}			}			else			{				for (i = itemVO.row + 1;i <= itemVO.row + vMove; i++)				{					if(_index[i][itemVO.col + hMove])					{						item = _index[i][itemVO.col + hMove];						item.row--;												_index[item.row][item.col] = item;						move.push(item);					}				}			}						for (i = 0;i < move.length; i++)			{				snapToGrid(move[i]);			}						itemVO.row = row;			itemVO.col = col;						_index[row][col] = itemVO;		}		private function snapToGrid(item : ShuffleGridItemVO) : void		{			var pos : Point = getPosition(item.row, item.col);			TweenLite.to(item.item, tweenTime, {x:pos.x, y:pos.y, ease:Expo.easeInOut});		}		private function getPosition(row : int, col : int) : Point		{			return new Point(col * (_colSize + _padd), row * (_rowSize + _padd));		}		private function getCell(x : Number, y : Number) : Point		{			var cell : Point = new Point();						//trace("x = " + x + ", colSize = "+ _colSize+", cell = "+Math.round(x / (_colSize + _padd)));						cell.x = Math.max(0, Math.min(_cols - 1, Math.floor(x / (_colSize + _padd))));			cell.y = Math.max(0, Math.min(_rows - 1, Math.floor(y / (_rowSize + _padd))));						return cell;		}				private var oldPosition:Point;		private var newPosition:Point;				private function onItemPress(event : MouseEvent) : void		{			_currentItem = event.currentTarget as ShuffleGridItem;			_currentItem.addEventListener(MouseEvent.MOUSE_OUT, onItemRelease);			_currentItem.alpha = itemAlphaOff;			_currentItem.startDrag();						oldPosition = getCell(event.stageX - onScreenXOffset, event.stageY - onScreenYOffset);						stage.addEventListener(MouseEvent.MOUSE_MOVE, onItemMove);			addChild(_currentItem);		}		private function onItemMove(event : MouseEvent) : void		{			//shuffleItems();		}		private function onItemRelease(event : MouseEvent) : void		{			_currentItem.removeEventListener(MouseEvent.MOUSE_OUT, onItemRelease);			_currentItem.alpha = 1.0;			_currentItem.stopDrag();						newPosition = getCell(event.stageX - onScreenXOffset, event.stageY - onScreenYOffset);						var oldLevelNum = getLevelNumFromCell(oldPosition);			var newLevelNum = getLevelNumFromCell(newPosition);						var moves:Array = [];						if (oldLevelNum < newLevelNum) { //move items down				for (var row = newPosition.y; row >= oldPosition.y; row--) {					for (var col = cols - 1; col >= 0; col--) {						if (getLevelNumFromCell(new Point(col, row)) > newLevelNum || getLevelNumFromCell(new Point(col, row)) < oldLevelNum) {							continue;						}						var item:ShuffleGridItemVO = _index[row][col];						if (item != null) {							if (col > 0) {								item.col--;							} else {								item.col = cols - 1;								item.row = Math.max(0, item.row - 1);							}														moves.push(item);						}					}				}			} else if (oldLevelNum > newLevelNum) { //move items up				for (var row = oldPosition.y; row >= newPosition.y; row--) {					for (var col = cols - 1; col >= 0; col--) {						if (getLevelNumFromCell(new Point(col, row)) < newLevelNum || getLevelNumFromCell(new Point(col, row)) > oldLevelNum) {							continue;						}						var item:ShuffleGridItemVO = _index[row][col];						if (item != null) {							if (col < cols - 1) {								item.col++;							} else {								item.col = 0;								item.row = Math.min(rows-1, item.row + 1);							}														moves.push(item);						}					}				}			}						var movedItem:ShuffleGridItemVO = _index[oldPosition.y][oldPosition.x];			var replacingItem:ShuffleGridItemVO = _index[newPosition.y][newPosition.x];			if (replacingItem != null) {				movedItem.row = newPosition.y;				movedItem.col = newPosition.x;							}			moves.push(movedItem);			//for each (var item:ShuffleGridItemVO in moves) {				//_index[item.row][item.col] = item;			//}			for (var i = 0;i < moves.length; i++)			{				_index[moves[i].row][moves[i].col] = moves[i];				snapToGrid(moves[i]);			}						//UPDATE MOVED LEVEL POS						stage.removeEventListener(MouseEvent.MOUSE_MOVE, onItemMove);			snapToGrid(_dictionary[_currentItem]);		}				private function getLevelNumFromCell(cell:Point):int {			return (cell.y * cols) + (cell.x + 1);		}	}}import ui.levelorderer.ShuffleGridItem;internal class ShuffleGridItemVO{	public var row : int;	public var col : int;	public var item : ShuffleGridItem;}